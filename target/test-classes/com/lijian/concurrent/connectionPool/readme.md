从线程池的实现可以看到，当客户端调用execute（job)方法时，会不断的向任务列表jobs中添加Job
而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态
添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够确定工作者线程被唤醒，这时使用nofity（）方法将会比notifyAll（）
方法获得更小的开销（避免将等待队列中的线程全部移动到阻塞队列中。
线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断从工作队列上取出工作并执行。
当工作队列为空时，所有工作者线程均等待工作队列上，当有客户端提交了一个任务之后会通知任务一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。
